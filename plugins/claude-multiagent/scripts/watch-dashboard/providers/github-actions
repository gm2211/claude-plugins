#!/usr/bin/env bash
# GitHub Actions workflow provider for deploy-watch.
# Responds to: name, config, list
#
# Environment variables (set by watch-dashboard via DEPLOY_WATCH_* prefix):
#   DEPLOY_WATCH_REPO  â€” GitHub repo slug, e.g. "owner/repo"
#                        If not set, auto-detected from the git remote.

set -euo pipefail

CMD="${1:-}"

# Detect the GitHub repo slug from the current git remote (origin).
# Returns "owner/repo" or empty string on failure.
detect_repo() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null) || return 1

    # Strip .git suffix and extract owner/repo
    # Handles:
    #   https://github.com/owner/repo.git
    #   https://github.com/owner/repo
    #   git@github.com:owner/repo.git
    #   git@github.com:owner/repo
    local slug
    slug=$(echo "$remote_url" \
        | sed -E 's|.*github\.com[:/]([^/]+/[^/]+)(\.git)?$|\1|' \
        | sed -E 's|\.git$||')

    # Verify it looks like owner/repo
    if [[ "$slug" =~ ^[^/]+/[^/]+$ ]]; then
        echo "$slug"
    fi
}

cmd_name() {
    echo "GitHub Actions"
}

cmd_config() {
    local default_repo
    default_repo=$(detect_repo 2>/dev/null) || default_repo=""

    # Emit JSON config. If we detected a repo, provide it as the default so the
    # user can just press Enter during interactive setup.
    if [[ -n "$default_repo" ]]; then
        jq -n --arg repo "$default_repo" '{
            fields: [{
                key: "repo",
                label: "GitHub repo (owner/name)",
                required: false,
                default: $repo
            }]
        }'
    else
        echo '{
  "fields": [
    {
      "key": "repo",
      "label": "GitHub repo (owner/name)",
      "required": true
    }
  ]
}'
    fi
}

cmd_list() {
    local repo="${DEPLOY_WATCH_REPO:-}"

    # Fall back to auto-detection if not configured
    if [[ -z "$repo" ]]; then
        repo=$(detect_repo 2>/dev/null) || repo=""
    fi

    if [[ -z "$repo" ]]; then
        echo "Error: could not determine GitHub repo. Set DEPLOY_WATCH_REPO or run from inside a GitHub-hosted git repo." >&2
        exit 1
    fi

    # Fetch recent workflow runs as JSON
    local raw
    if ! raw=$(gh run list \
        --repo "$repo" \
        --limit 5 \
        --json "headSha,workflowName,headBranch,event,status,conclusion,createdAt,updatedAt,url" \
        2>/dev/null); then
        echo "Error: gh run list failed for repo '$repo'" >&2
        exit 1
    fi

    # Parse each run with jq and emit JSONL
    # tag: use headBranch if it looks like a semver tag (starts with v and matches v<digits>...)
    #      or if the event is "release", otherwise empty string
    # environment: inferred from branch name or event
    echo "$raw" | jq -c '.[] | {
        commit: (.headSha[:7]),
        message: (.workflowName + " [" + .headBranch + "]"),
        author: "",
        tag: (
            if (.headBranch | test("^v[0-9]"))
            then .headBranch
            elif (.event == "release")
            then .headBranch
            else ""
            end
        ),
        environment: (
            (.workflowName // "" | ascii_downcase) as $wf
            | (.headBranch // "") as $branch
            | if ($wf | test("staging|\\bstg\\b")) then "staging"
              elif ($wf | test("production|\\bprod\\b")) then "prod"
              elif ($wf | test("preview|\\bdev\\b|develop")) then "dev"
              elif (.event == "release") then "prod"
              elif ($branch | test("^v[0-9]")) then "prod"
              elif ($branch == "main" or $branch == "master") then "prod"
              elif ($branch == "staging" or $branch == "stg") then "staging"
              elif ($branch == "dev" or $branch == "develop") then "dev"
              else ""
              end
        ),
        build_status: (
            if .status == "completed" then
                if .conclusion == "success" then "success"
                elif .conclusion == "failure" then "failed"
                elif .conclusion == "cancelled" then "cancelled"
                elif .conclusion == "skipped" then "cancelled"
                else (.conclusion // "failed")
                end
            elif .status == "in_progress" then "building"
            elif .status == "queued" then "pending"
            elif .status == "waiting" then "pending"
            else "pending"
            end
        ),
        deploy_status: (
            if .status == "completed" then
                if .conclusion == "success" then "live"
                elif .conclusion == "failure" then "failed"
                elif .conclusion == "cancelled" then "cancelled"
                elif .conclusion == "skipped" then "cancelled"
                else (.conclusion // "failed")
                end
            elif .status == "in_progress" then "deploying"
            elif .status == "queued" then "pending"
            elif .status == "waiting" then "pending"
            else "pending"
            end
        ),
        build_started: (
            .createdAt |
            if (. != null and . != "") then
                (strptime("%Y-%m-%dT%H:%M:%SZ") | mktime | tostring)
            else ""
            end
        ),
        deploy_finished: (
            if .status == "completed" then
                (.updatedAt |
                 if (. != null and . != "") then
                     (strptime("%Y-%m-%dT%H:%M:%SZ") | mktime | tostring)
                 else ""
                 end)
            else ""
            end
        ),
        service_url: .url
    }'
}

case "$CMD" in
    name)   cmd_name ;;
    config) cmd_config ;;
    list)   cmd_list ;;
    *)
        echo "Usage: github-actions <name|config|list>" >&2
        exit 1
        ;;
esac
