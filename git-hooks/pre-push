#!/bin/sh
#
# pre-push hook — version-bump guard
#
# Auto-bumps the patch version in marketplace.json when plugin files have
# changed without a corresponding version bump, amends HEAD, then exits 1
# so the caller can push again with the updated SHA.
#
# Delegates to bd pre-push logic first (if available).
#

# --- bd (beads) pre-push delegation ---
if command -v bd >/dev/null 2>&1; then
    bd hooks run pre-push "$@"
    BD_EXIT=$?
    if [ "$BD_EXIT" -ne 0 ]; then
        exit "$BD_EXIT"
    fi
fi

# --- Submodule dirty-check ---
#
# Warn (non-blocking) if any plugin submodules have a checked-out commit that
# differs from the committed pointer.  This catches the common mistake of
# updating a submodule locally (e.g. `cd sub && git pull`) without staging the
# new pointer in the parent repo via `git add <submodule>`.
#
# `git submodule status` prefixes:
#   +  = checked-out commit differs from index (dirty pointer)
#   -  = submodule not initialised
#   U  = merge conflict
# We only flag "+" for submodules under plugins/.

DIRTY_SUBS=""
if git submodule status -- plugins/ 2>/dev/null | grep -q '^\+'; then
    DIRTY_SUBS=$(git submodule status -- plugins/ 2>/dev/null | grep '^\+' | while read -r line; do
        sub_path=$(echo "$line" | awk '{print $2}')
        sub_commit=$(echo "$line" | sed 's/^+//' | awk '{print $1}')
        printf "      %s (checked out: %.8s)\n" "$sub_path" "$sub_commit"
    done)
fi

if [ -n "$DIRTY_SUBS" ]; then
    echo "" >&2
    echo "=== Push rejected: dirty submodule pointers ===" >&2
    echo "  The following plugin submodules have been modified locally" >&2
    echo "  but the new pointer has NOT been committed:" >&2
    echo "" >&2
    printf "%s\n" "$DIRTY_SUBS" >&2
    echo "" >&2
    echo "  Fix: git add <submodule-path> && git commit --amend" >&2
    echo "  Or ignore if this is intentional." >&2
    echo "" >&2
    # Hard-block: reject the push so users don't ship stale submodule content.
    exit 1
fi

# --- Version-bump check (auto-bump) ---
#
# Git pre-push hook receives lines on stdin:
#   <local ref> <local sha> <remote ref> <remote sha>
#
# When plugin files have changed without a version bump we patch the version
# in marketplace.json in-place, amend HEAD, and exit 1 so the caller can
# push again with the new SHA.

MARKETPLACE_JSON=".claude-plugin/marketplace.json"
PLUGIN_JSON="plugins/claude-multiagent/.claude-plugin/plugin.json"

# Collect plugins that need bumping across all pushed refs.
# Format: newline-separated "PLUGIN_NAME OLD_VERSION"
NEEDS_BUMP=""

while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    # Skip delete pushes
    if [ "$LOCAL_SHA" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Determine the range of commits being pushed
    if [ "$REMOTE_SHA" = "0000000000000000000000000000000000000000" ]; then
        # New branch — compare against the merge-base with main/master
        DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        if [ -z "$DEFAULT_BRANCH" ]; then
            DEFAULT_BRANCH="main"
        fi
        BASE=$(git merge-base "$LOCAL_SHA" "origin/$DEFAULT_BRANCH" 2>/dev/null || echo "")
        if [ -z "$BASE" ]; then
            # Can't determine base, skip check
            continue
        fi
        RANGE="${BASE}..${LOCAL_SHA}"
        VERSION_BASE="$BASE"
    else
        RANGE="${REMOTE_SHA}..${LOCAL_SHA}"
        VERSION_BASE="$REMOTE_SHA"
    fi

    for PLUGIN_DIR in plugins/*/; do
        PLUGIN_NAME=$(basename "$PLUGIN_DIR")

        # Check if any files in this plugin changed (excluding metadata files)
        CHANGED=$(git diff --name-only "$RANGE" -- "$PLUGIN_DIR" 2>/dev/null | grep -v "\.claude-plugin/plugin\.json$" | grep -v "\.claude-plugin/marketplace\.json$" || true)
        [ -z "$CHANGED" ] && continue

        # Extract old and new versions from marketplace.json
        OLD_VERSION=$(git show "${VERSION_BASE}:${MARKETPLACE_JSON}" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
for p in data.get('plugins', []):
    if p.get('name') == '$PLUGIN_NAME':
        print(p.get('version', ''))
        break
" 2>/dev/null)

        NEW_VERSION=$(git show "${LOCAL_SHA}:${MARKETPLACE_JSON}" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
for p in data.get('plugins', []):
    if p.get('name') == '$PLUGIN_NAME':
        print(p.get('version', ''))
        break
" 2>/dev/null)

        # Plugin has no entry in marketplace.json — skip
        [ -z "$OLD_VERSION" ] && [ -z "$NEW_VERSION" ] && continue

        # New plugin with no prior version — skip
        [ -z "$OLD_VERSION" ] && continue

        # Version was already bumped — nothing to do
        if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ -n "$NEW_VERSION" ]; then
            continue
        fi

        # Record this plugin for auto-bumping (deduplicate by name)
        if ! printf "%s" "$NEEDS_BUMP" | grep -qF "$PLUGIN_NAME "; then
            NEEDS_BUMP="${NEEDS_BUMP}${PLUGIN_NAME} ${OLD_VERSION}
"
        fi
    done
done

# Nothing to auto-bump — all good.
[ -z "$NEEDS_BUMP" ] && exit 0

# --- Perform the auto-bumps ---
#
# Pass NEEDS_BUMP via a here-string so the while loop runs in the current
# shell and variable assignments (BUMP_SUMMARY) are visible after the loop.

BUMP_SUMMARY=""

while IFS=" " read -r PLUGIN_NAME OLD_VERSION; do
    [ -z "$PLUGIN_NAME" ] && continue

    NEW_VERSION=$(python3 -c "
import json

marketplace_path = '$MARKETPLACE_JSON'
plugin_name = '$PLUGIN_NAME'

with open(marketplace_path) as f:
    data = json.load(f)

new_version = None
for p in data.get('plugins', []):
    if p.get('name') == plugin_name:
        parts = p['version'].split('.')
        parts[-1] = str(int(parts[-1]) + 1)
        new_version = '.'.join(parts)
        p['version'] = new_version
        break

if new_version is not None:
    with open(marketplace_path, 'w') as f:
        json.dump(data, f, indent=2)
        f.write('\n')
    print(new_version)
" 2>/dev/null)

    # Also bump version in plugin.json to keep both files in sync
    if [ -n "$NEW_VERSION" ] && [ -f "$PLUGIN_JSON" ]; then
        python3 -c "
import json

plugin_json_path = '$PLUGIN_JSON'
new_version = '$NEW_VERSION'

with open(plugin_json_path) as f:
    data = json.load(f)

data['version'] = new_version

with open(plugin_json_path, 'w') as f:
    json.dump(data, f, indent=2)
    f.write('\n')
" 2>/dev/null
    fi

    BUMP_SUMMARY="${BUMP_SUMMARY}  Auto-bumped ${PLUGIN_NAME}: ${OLD_VERSION} -> ${NEW_VERSION}
"
done <<EOF
$NEEDS_BUMP
EOF

git add "$MARKETPLACE_JSON"
git add "$PLUGIN_JSON"
git commit --amend --no-edit

echo "" >&2
echo "=== Version auto-bumped ===" >&2
printf "%s" "$BUMP_SUMMARY" >&2
echo "" >&2
echo "HEAD was amended. Run \`git push\` again." >&2
echo "" >&2
exit 1
