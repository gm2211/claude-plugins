#!/bin/sh
#
# pre-push hook — version-bump & marketplace-sync guard
#
# Rejects a push if any plugin directory has changes (vs the remote tip)
# without a corresponding version bump in plugin.json.
# Also rejects if marketplace.json versions are out of sync with plugin.json.
#
# Delegates to bd pre-push logic first (if available).
#

# --- bd (beads) pre-push delegation ---
if command -v bd >/dev/null 2>&1; then
    bd hooks run pre-push "$@"
    BD_EXIT=$?
    if [ "$BD_EXIT" -ne 0 ]; then
        exit "$BD_EXIT"
    fi
fi

# --- Submodule dirty-check ---
#
# Warn (non-blocking) if any plugin submodules have a checked-out commit that
# differs from the committed pointer.  This catches the common mistake of
# updating a submodule locally (e.g. `cd sub && git pull`) without staging the
# new pointer in the parent repo via `git add <submodule>`.
#
# `git submodule status` prefixes:
#   +  = checked-out commit differs from index (dirty pointer)
#   -  = submodule not initialised
#   U  = merge conflict
# We only flag "+" for submodules under plugins/.

DIRTY_SUBS=""
if git submodule status -- plugins/ 2>/dev/null | grep -q '^\+'; then
    DIRTY_SUBS=$(git submodule status -- plugins/ 2>/dev/null | grep '^\+' | while read -r line; do
        sub_path=$(echo "$line" | awk '{print $2}')
        sub_commit=$(echo "$line" | sed 's/^+//' | awk '{print $1}')
        printf "      %s (checked out: %.8s)\n" "$sub_path" "$sub_commit"
    done)
fi

if [ -n "$DIRTY_SUBS" ]; then
    echo "" >&2
    echo "=== Push rejected: dirty submodule pointers ===" >&2
    echo "  The following plugin submodules have been modified locally" >&2
    echo "  but the new pointer has NOT been committed:" >&2
    echo "" >&2
    printf "%s\n" "$DIRTY_SUBS" >&2
    echo "" >&2
    echo "  Fix: git add <submodule-path> && git commit --amend" >&2
    echo "  Or ignore if this is intentional." >&2
    echo "" >&2
    # Hard-block: reject the push so users don't ship stale submodule content.
    exit 1
fi

# --- Version-bump check ---
#
# Git pre-push hook receives lines on stdin:
#   <local ref> <local sha> <remote ref> <remote sha>
#
# We check each ref being pushed.

MARKETPLACE_JSON=".claude-plugin/marketplace.json"
ERRORS=""

while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    # Skip delete pushes
    if [ "$LOCAL_SHA" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Determine the range of commits being pushed
    if [ "$REMOTE_SHA" = "0000000000000000000000000000000000000000" ]; then
        # New branch — compare against the merge-base with main/master
        DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        if [ -z "$DEFAULT_BRANCH" ]; then
            DEFAULT_BRANCH="main"
        fi
        BASE=$(git merge-base "$LOCAL_SHA" "origin/$DEFAULT_BRANCH" 2>/dev/null || echo "")
        if [ -z "$BASE" ]; then
            # Can't determine base, skip check
            continue
        fi
        RANGE="${BASE}..${LOCAL_SHA}"
    else
        RANGE="${REMOTE_SHA}..${LOCAL_SHA}"
    fi

    for PLUGIN_DIR in plugins/*/; do
        PLUGIN_JSON="${PLUGIN_DIR}.claude-plugin/plugin.json"

        # Skip if this plugin has no plugin.json
        [ -f "$PLUGIN_JSON" ] || continue

        PLUGIN_NAME=$(basename "$PLUGIN_DIR")

        # Check if any files in this plugin changed (excluding plugin.json itself)
        CHANGED=$(git diff --name-only "$RANGE" -- "$PLUGIN_DIR" 2>/dev/null | grep -v "\.claude-plugin/plugin\.json$" || true)
        [ -z "$CHANGED" ] && continue

        # Plugin files changed — check if version was bumped
        OLD_VERSION=$(git show "${REMOTE_SHA}:${PLUGIN_JSON}" 2>/dev/null | grep '"version"' | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
        NEW_VERSION=$(git show "${LOCAL_SHA}:${PLUGIN_JSON}" 2>/dev/null | grep '"version"' | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

        # New plugin with no prior version — skip
        [ -z "$OLD_VERSION" ] && continue

        if [ "$OLD_VERSION" = "$NEW_VERSION" ] || [ -z "$NEW_VERSION" ]; then
            ERRORS="${ERRORS}\n  - Plugin '$PLUGIN_NAME': files changed but version not bumped (still $OLD_VERSION)"
            ERRORS="${ERRORS}\n    Changed files:"
            while read -r F; do
                ERRORS="${ERRORS}\n      $F"
            done <<< "$CHANGED"
            continue
        fi

        # Version was bumped — check marketplace sync
        if [ -f "$MARKETPLACE_JSON" ]; then
            MARKETPLACE_VERSION=$(git show "${LOCAL_SHA}:${MARKETPLACE_JSON}" 2>/dev/null | python3 -c "
import json, sys
data = json.load(sys.stdin)
for p in data.get('plugins', []):
    if p.get('name') == '$PLUGIN_NAME':
        print(p.get('version', ''))
        break
" 2>/dev/null)

            if [ -n "$MARKETPLACE_VERSION" ] && [ "$MARKETPLACE_VERSION" != "$NEW_VERSION" ]; then
                ERRORS="${ERRORS}\n  - Plugin '$PLUGIN_NAME': marketplace.json version ($MARKETPLACE_VERSION) != plugin.json version ($NEW_VERSION)"
            fi
        fi
    done

    # Check marketplace top-level version matches highest plugin version
    if [ -f "$MARKETPLACE_JSON" ]; then
        HIGHEST_PLUGIN_VERSION=""
        for PLUGIN_DIR in plugins/*/; do
            PLUGIN_JSON="${PLUGIN_DIR}.claude-plugin/plugin.json"
            [ -f "$PLUGIN_JSON" ] || continue
            V=$(git show "${LOCAL_SHA}:${PLUGIN_JSON}" 2>/dev/null | grep '"version"' | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
            if [ -n "$V" ]; then
                if [ -z "$HIGHEST_PLUGIN_VERSION" ] || printf '%s\n%s\n' "$HIGHEST_PLUGIN_VERSION" "$V" | sort -V | tail -1 | grep -q "^${V}$"; then
                    HIGHEST_PLUGIN_VERSION="$V"
                fi
            fi
        done
    fi
done

if [ -n "$ERRORS" ]; then
    echo "" >&2
    echo "=== Push rejected: plugin version issues ===" >&2
    printf "%b\n" "$ERRORS" >&2
    echo "" >&2
    echo "Fix: bump the version in plugin.json, update marketplace.json, commit, and retry." >&2
    echo "" >&2
    exit 1
fi

exit 0
